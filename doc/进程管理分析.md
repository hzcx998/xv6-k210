# xv6-210进程管理分析
```
procinit: 来初始化进程表
userinit: 进行用户态程序的初始化
[
    allocproc: 分配一个进程
    [
        循环从进程中分配一个可用进程
        allocpid: 分配一个进程id
        kalloc分配一个页给trapframe
        proc_pagetable: 分配用户页表
        [
            uvmcreate: 创建空页表
            mappages: 映射trampoline代码到TRAMPOLINE地址上
            mappages: 映射进程的trapframe代码到TRAPFRAME地址上
        ]
        proc_kpagetable: 分配内核页表
        [
            kalloc: 分配一个页给kpt
            memmove: 复制kernel_pagetable到kpt中，相当于内核页表备份
            kalloc: 分配一个页给pstack，时内核栈的映射
            mappages: 映射pstack到VKSTACK地址上面
        ]
        kstack: 设置内核栈顶位置
        context: 初始化上下文的值
        [
            context.ra: 设置为forkret，当被调度时就会跳转过去
            context.sp: 设置内核执行时的栈顶为kstack + PGSIZE
        ]
    ]
    uvminit: 初始化用户态的代码，栈等
    [
        kalloc: 分配一个页的内存给mem
        mappages：映射pagetable的从0开始的一个页，并且映射mem
        mappages：映射pkpagetable的从0开始的一个页，并且映射mem
        memmove: 复制init代码到mem中，完成了用户态程序的代码、数据加载
    ]
    trapframe: 设置用户态运行时的寄存器
    [
        trapframe.epc: 用户态程序的入口设置，这里是0
        trapframe.sp: 用户态程序的栈，这里是PGSIZE
    ]
    safestrcpy: 设置进程的名字为initcode
    state: 设置进程状态为RUNNABLE
]
scheduler: 调度器进行调度
[
    mycpu: 获取当前cpu
    kernel_pagetable: 内核的全局页表
    intr_on: 打开中断，避免死锁
    p: 循环从进程表中取得一个进程
    state: 状态为RUNNABLE的就可以进行调度
    [
        state: 设置状态为RUNNING，表示当前进程处于执行状态
        c->proc: 设置cpu当前进程为p
        w_satp: 激活页表，此时传入的是p的内核页表kpagetable
        sfence_vma: 刷新TLB
        swtch: 切换上下文，切换为p
        w_satp: 激活页表，此时传入的是全局的内核页表kernel_pagetable
        sfence_vma: 刷新TLB
    ]
]

forkret: 从fork中返回，也是第一次从内核回到用户态的执行入口
[
    first: 是否是第一次执行
    release: 释放当前进程的锁
    fat32_init: 第一次执行forkret时需要初始化文件系统
    usertrapret: 从用户trap返回
    [
        myproc: 获取当前进程
        intr_off: 关闭中断
        w_stvec: 修改中断处理入口程序为TRAMPOLINE内的代码uservec的地址
        trapframe: 记录内核状态下的一些特殊值，等下次进入内核时需要使用这些值
        [
            kernel_satp: 保存内核页表值
            kernel_sp: 内核栈顶
            kernel_trap: 内核的trap地址
            kernel_hartid: cpuid
        ]
        w_sstatus: 修改当前的模式从S变成U，并允许产生中断
        w_sepc: 将trapframe的epc写入该地址，记录了异常产生时的地址
        satp: 构建页表pagetable
        fn: 指向userret的地址，并调用该函数，传入TRAPFRAME, satp作为参数
    ]
]

userret: 返回用户态，写入用户页表，恢复寄存器
[
    csrw: 将a1(pagetable)写入satp寄存器，切换页表
    sfence.vma: 刷新页表TLB
    csrw: 将用户态的a0保存到sscratch中
    :从TRAPFRAME中恢复所有除了a0的寄存器
    csrrw: 从sscratch中恢复a0
    sret: 返回到用户模式
]


```
